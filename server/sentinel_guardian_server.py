
import RPi.GPIO as GPIO
import time
import socket
import atexit
import signal
import threading

from gpio_controller import GPIOController
from networking import NetworkSettings, Client
from logging import Logging

g_ALARM_BEEP_MAX_DURATION = 20


# store the list of clients
# todo: may need to create a thread-safe class later
_clients_lock = threading.Lock()
clients = []

# use this to keep track of the current event,
# and ignore old events
# set to None if no event is currently active
# must be an 'int' when active. NO FLOATS
current_event_start_timestamp = None

_button_press_event_lock = threading.Lock()
def on_press(gpio_pin):

	if not _button_press_event_lock.acquire(blocking=False):
		Logging.info("Ignoring duplicate door bell button press")
		return

	Logging.info("Door bell button is pressed")

	if not len(clients):
		GPIOController.LED.set_red()
		Logging.warn("Door bell set to RED due to no clients available")
		_button_press_event_lock.release()
		return

	global current_event_start_timestamp
	current_event_start_timestamp = int(time.time())

	GPIOController.LED.blink_blue()
	
	with _clients_lock:
		for client in clients:
			client.send_packet(current_event_start_timestamp, NetworkSettings.State.START_BEEP)
	
	_button_press_event_lock.release()
	# todo: add some sort of validation logic
	# not here though, needs to exit fast because this
	# will be an ISR


def handle_packet(packet):

	global current_event_start_timestamp

	if packet.protocol_ver != NetworkSettings.PROTOCOL_VERSION:
		Logging.warn(f"Client at {packet.ip_address} using protocol version {packet.protocol_ver}. We expect {NetworkSettings.PROTOCOL_VERSION}")

	# check that packet is actually recent
	# zero is used for creating a connection
	#
	# there is NEVER a situation where the incoming timestamp
	# is higher than the server current timestamp, as this is
	# generated by the server, and only ever incremented, or set
	# to 0
	if not packet.event_timestamp in (0, current_event_start_timestamp):
		Logging.info("Ignoring old packet")
		return

	with _clients_lock:
		
		# try to find client
		client = None
		for loop_client in clients:
			if loop_client.ip_address == packet.ip_address:
				client = loop_client
				break


		if packet.state == NetworkSettings.State.SEEKING_CONNECTION:

			# create client
			if client is None:
				client = Client(packet.ip_address, packet.state)
				clients.append(client)
				Logging.info(f"Added client at {client.ip_address}")

			# acknowledge connection request
			client.send_packet(0, NetworkSettings.State.CONNECTION_ACCEPTED)
		

		# we will only recieve this packet as an acknowledgement/echo
		if packet.state == NetworkSettings.State.START_BEEP:

			if client is None:
				Logging.error("Non-existing client send us a start beep acknowledment packet. Should not be possible")
				return
			
			client.update_state(packet)
		

		if packet.state == NetworkSettings.State.STOP_BEEP:

			if client is None:
				Logging.error("Non-existing client send us a stop beep packet. Should not be possible")
				return

			# only redistribute if an event in in-progress
			# we purposely echo back to client so they know
			# the packet has been handled
			if not current_event_start_timestamp is None:
				Logging.info(f"Current alarm canceled by {packet.ip_address}")

				current_event_start_timestamp = None
				GPIOController.LED.set_green()

				for loop_client in clients:
					loop_client.send_packet(packet.event_timestamp, NetworkSettings.State.STOP_BEEP)
			
			# but the client status gets updated regardless
			client.update_state(packet)

		
		# this packet is only recieved as an acknowledgement of being alive
		if packet.state == NetworkSettings.State.IDLE:
			
			if client is None:
				Logging.error("Non-existing client send us an IDLE/heartbeat packet. Should not be possible")
				return
			
			Logging.debug(f"Alive ACK recieved from {packet.ip_address}")
			client.update_last_seen_ts()



def cleanup():
	GPIO.cleanup()




def init():

	Logging.info("Init function reached")
	
	GPIOController.init(on_press_callback=on_press)
	
	atexit.register(cleanup)
	signal.signal(signal.SIGTERM, lambda *args: cleanup() or exit(0))

	threading.Thread(
		target=NetworkSettings.inbound_packet_listener,
		args=(handle_packet,), daemon=True).start()


def loop():

	global current_event_start_timestamp
	
	time.sleep(1)
	

	# handle ACK messages

	current_time = int(time.time())

	with _clients_lock:
		clients_index = len(clients)

		while clients_index:
			clients_index -= 1

			time_since_last_packet = current_time - clients[clients_index].last_packet_real_ts

			if time_since_last_packet > NetworkSettings.TIMEOUT_DURATION:
				Logging.info(f"Removing client at {clients[clients_index].ip_address}")
				del clients[clients_index]
			
			elif time_since_last_packet > NetworkSettings.SEND_IDLE_ACK_AFTER_DURATION:

				# rate limit to one ping every x seconds
				if int(time.time()) - clients[clients_index].last_ack_packet_sent_ts > 20:
					Logging.debug(f"Pinging client at {clients[clients_index].ip_address} to check it's alive")
					clients[clients_index].last_ack_packet_sent_ts = int(time.time())
					clients[clients_index].send_packet(0, NetworkSettings.State.IDLE)
	
	
	# handle alarm timeout

	current_time = int(time.time())  # just incase networking takes a while

	if not current_event_start_timestamp is None:
		if current_time - current_event_start_timestamp > g_ALARM_BEEP_MAX_DURATION:

			Logging.info("Alarm timed out")

			GPIOController.LED.set_red()

			with _clients_lock:
				for loop_client in clients:
					loop_client.send_packet(current_event_start_timestamp, NetworkSettings.State.STOP_BEEP)

			current_event_start_timestamp = None


if __name__ == "__main__":
	try:
		init()
		while 1:
			loop()
	except KeyboardInterrupt:
		pass
	finally:
		GPIO.cleanup()


